# 辰序（Chronos）开发者文档

## 项目信息

- **包名**: `com.chronos.calendar`
- **应用ID**: `com.chronos.calendar`
- **最小SDK**: 24 (Android 7.0)
- **目标SDK**: 36 (Android 14)
- **编译SDK**: 36

## 构建配置

### Gradle配置文件

#### `build.gradle.kts` (app)
```kotlin
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.kapt)  // Room需要
}

android {
    namespace = "com.chronos.calendar"
    compileSdk = 36
    
    buildFeatures {
        viewBinding = true  // 启用ViewBinding
    }
}
```

### 主要依赖

| 库 | 用途 |
|---|---|
| Room | 本地数据库 |
| Lifecycle (ViewModel, LiveData) | MVVM架构 |
| Coroutines | 异步编程 |
| WorkManager | 后台任务 |
| ViewPager2 | 页面滑动 |
| Material Design 3 | UI组件 |

## 核心组件说明

### 1. 数据模型 (data/)

#### Event.kt - 事件实体
```kotlin
@Entity(tableName = "events")
data class Event(
    @PrimaryKey(autoGenerate = true) val id: Long,
    val title: String,
    val startTime: Long,
    val endTime: Long,
    val reminderMinutes: Int,
    // ... 其他字段
)
```

**关键扩展函数**:
- `isOnDate(Calendar)` - 判断事件是否在指定日期
- `isInDateRange(start, end)` - 判断事件是否在时间范围内
- `getDurationMinutes()` - 获取事件时长

#### EventDao.kt - 数据访问
```kotlin
@Dao
interface EventDao {
    @Query("SELECT * FROM events ORDER BY startTime ASC")
    fun getAllEvents(): LiveData<List<Event>>
    
    @Query("SELECT * FROM events WHERE startTime >= :startTime AND endTime <= :endTime")
    fun getEventsInRange(startTime: Long, endTime: Long): LiveData<List<Event>>
    
    @Insert
    suspend fun insert(event: Event): Long
    
    @Update
    suspend fun update(event: Event)
    
    @Delete
    suspend fun delete(event: Event)
}
```

#### EventRepository.kt - 数据仓库
封装数据访问逻辑，提供简洁的API给ViewModel使用。

### 2. 视图模型 (viewmodel/)

#### EventViewModel.kt
```kotlin
class EventViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: EventRepository
    val allEvents: LiveData<List<Event>>
    
    fun insert(event: Event, onComplete: ((Long) -> Unit)?)
    fun update(event: Event, onComplete: (() -> Unit)?)
    fun delete(event: Event, onComplete: (() -> Unit)?)
    suspend fun getEventById(eventId: Long): Event?
}
```

**使用方式**:
```kotlin
// 在Activity/Fragment中
private val viewModel: EventViewModel by viewModels()

// 观察数据变化
viewModel.allEvents.observe(this) { events ->
    // 更新UI
}

// 添加事件
viewModel.insert(event) { eventId ->
    // 完成回调
}
```

### 3. UI组件 (ui/)

#### MainActivity.kt
主Activity，管理ViewPager2和视图切换。

**关键功能**:
- ViewPager2配置和适配器设置
- TabLayout与ViewPager2联动
- FAB按钮点击处理
- 菜单项处理（视图切换、返回今天）

#### CalendarViewPagerAdapter.kt
```kotlin
class CalendarViewPagerAdapter(
    fragmentActivity: FragmentActivity,
    private val viewMode: CalendarViewMode
) : FragmentStateAdapter(fragmentActivity) {
    
    companion object {
        const val START_POSITION = 1000  // 中间起始位置
        private const val TOTAL_PAGES = 2000  // 总页数
    }
    
    override fun createFragment(position: Int): Fragment {
        val offset = position - START_POSITION
        return when (viewMode) {
            CalendarViewMode.MONTH -> MonthViewFragment.newInstance(offset)
            CalendarViewMode.WEEK -> WeekViewFragment.newInstance(offset)
            CalendarViewMode.DAY -> DayViewFragment.newInstance(offset)
        }
    }
}
```

#### MonthViewFragment.kt
月视图Fragment，使用RecyclerView + GridLayoutManager显示日历网格。

#### MonthCalendarAdapter.kt
月历适配器，管理42个日期单元格（6行×7列）。

**日期计算逻辑**:
```kotlin
fun setMonth(calendar: Calendar) {
    // 1. 计算本月1号是星期几
    val firstDayOfWeek = monthCalendar.get(Calendar.DAY_OF_WEEK) - 1
    
    // 2. 添加上月末尾几天
    for (i in firstDayOfWeek - 1 downTo 0) { ... }
    
    // 3. 添加本月所有日期
    for (day in 1..daysInMonth) { ... }
    
    // 4. 添加下月开头几天，补足6行
    val remainingDays = 42 - days.size
    for (day in 1..remainingDays) { ... }
}
```

#### EventBottomSheetFragment.kt
底部弹窗，处理事件的添加和编辑。

**关键功能**:
- DatePickerDialog / TimePickerDialog
- 数据验证（标题必填、时间有效性）
- 删除确认对话框

### 4. 通知提醒 (notification/)

#### EventReminderWorker.kt
```kotlin
class EventReminderWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        // 1. 获取需要提醒的事件
        val upcomingEvents = repository.getUpcomingEventsWithReminders()
        
        // 2. 检查是否到达提醒时间
        upcomingEvents.forEach { event ->
            val reminderTime = calculateReminderTime(event)
            if (isTimeToRemind(reminderTime)) {
                sendNotification(event)
            }
        }
        
        return Result.success()
    }
}
```

#### ReminderScheduler.kt
```kotlin
object ReminderScheduler {
    fun scheduleReminderCheck(context: Context) {
        val workRequest = PeriodicWorkRequestBuilder<EventReminderWorker>(
            15, TimeUnit.MINUTES  // 每15分钟检查一次
        ).build()
        
        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            WORK_NAME,
            ExistingPeriodicWorkPolicy.KEEP,
            workRequest
        )
    }
}
```

## 数据流程

### 添加事件流程
```
用户输入 → EventBottomSheetFragment 
         → EventViewModel.insert()
         → EventRepository.insert()
         → EventDao.insert()
         → Room Database
         → LiveData更新
         → UI自动刷新
```

### 查询事件流程
```
Fragment启动 → 观察ViewModel的LiveData
           → Repository返回LiveData<List<Event>>
           → Room自动查询
           → 数据变化时LiveData回调
           → Adapter更新
           → RecyclerView刷新
```

### 提醒流程
```
App启动 → ChronosApplication.onCreate()
       → ReminderScheduler.scheduleReminderCheck()
       → WorkManager定期执行EventReminderWorker
       → 检查待提醒事件
       → 发送系统通知
```

## 关键代码片段

### ViewBinding使用
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // 直接使用binding访问视图
        binding.fab.setOnClickListener { ... }
    }
}
```

### Coroutines使用
```kotlin
// 在ViewModel中
fun insert(event: Event, onComplete: ((Long) -> Unit)? = null) {
    viewModelScope.launch {
        val id = repository.insert(event)  // suspend函数
        onComplete?.invoke(id)
    }
}

// 在Fragment中
lifecycleScope.launch {
    val event = viewModel.getEventById(eventId)
    // 更新UI
}
```

### LiveData观察
```kotlin
viewModel.selectedDate.observe(viewLifecycleOwner) { date ->
    updateUI(date)
}
```

## 调试技巧

### 1. 查看数据库
使用Android Studio的Database Inspector：
```
View -> Tool Windows -> App Inspection -> Database Inspector
```

### 2. 日志输出
```kotlin
Log.d("MainActivity", "按钮被点击了")
Log.d("EventReminderWorker", "发送通知: ${event.title}")
```

### 3. WorkManager调试
```kotlin
// 查看Work状态
val workInfos = WorkManager.getInstance(context)
    .getWorkInfosForUniqueWork("event_reminder_check")
    .get()
```

## 常见问题解决

### Q1: Room编译错误
**A**: 确保在`build.gradle.kts`中添加了kapt插件：
```kotlin
plugins {
    alias(libs.plugins.kotlin.kapt)
}
```

### Q2: ViewBinding未生成
**A**: 检查是否启用了ViewBinding：
```kotlin
android {
    buildFeatures {
        viewBinding = true
    }
}
```

### Q3: WorkManager不工作
**A**: 
1. 检查是否在Application的onCreate中调度
2. 确认系统未限制后台运行
3. 使用一次性Worker测试

## 扩展开发建议

### 添加重复日程
1. 在Event中使用recurrenceRule字段
2. 创建RecurrenceRule解析器
3. 在查询时展开重复日程
4. UI添加重复选项

### 添加多日历
1. 创建Calendar实体
2. Event添加calendarId外键
3. UI添加日历选择器
4. 支持日历颜色

### 数据导入导出
1. 实现iCalendar格式解析
2. 创建ICS文件生成器
3. 添加分享功能

## 代码风格

- 使用Kotlin惯用语法
- 遵循Material Design指南
- 注释关键业务逻辑
- 函数单一职责
- 合理使用扩展函数

## 测试建议

### 单元测试
- Repository测试
- ViewModel测试
- 日期计算逻辑测试

### UI测试
- Espresso测试关键流程
- 测试日程添加/编辑/删除

---

**Happy Coding!** 🚀

